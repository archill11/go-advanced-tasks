package pattern

import (
	"fmt"
	"io"
	"strings"
)

/*
	Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

// Шаблон цепочка вызовов, состоит из цепочки и каждое звено цепочки следует принципу единой ответственности.

// Описание
// Принцип единой ответственности подразумевает, что тип, функция, метод или любая подобная
// абстракция должны нести только одну ответственность и выполнять ее достаточно хорошо.
// Таким образом, мы можем применить множество функций, которые достигают одной конкретной цели каждая, к некоторой структуре, срезу, карте и так далее.
// Когда мы очень часто применяем многие из этих абстракций логическим образом, мы можем связать их в цепочку
// для выполнения в порядке, таком как, например, цепочка логгирования.
// Цепочка логгирования - это набор типов, которые регистрируют выходные данные некоторой программы более чем в одном интерфейсе io.Writer.
// У нас мог бы быть тип, который регистрируется на консоли, тип, который регистрируется в файле,
// и тип, который регистрируется на удаленном сервере. Вы можете делать три вызова каждый раз, когда хотите выполнить
// какое-либо протоколирование, но более элегантно сделать только один и спровоцировать цепную реакцию.
// Но также у нас могла бы быть цепочка проверок и, в случае, если одна из них завершится неудачей, разорвать цепочку и вернуть что-то.

// Цели
// Динамически связывать действия во время выполнения на основе некоторых входных данных.
// Передавать запрос через цепочку процессоров до тех пор, пока один из них не сможет его обработать, и в этом случае цепочка может быть остановлена

// multi-logger chain
// Мы собираемся разработать multi-logger chain, которое мы можем объединить в цепочку так, как мы хотим.
// Мы будем использовать два разных консольных логгера и один логгер общего назначения:

type ChainLogger interface {
	Next(string) // Next - метод, который выполняет следующее звено в цепочке
}

// Нам нужен простой логгер, который регистрирует текст запроса с префиксом First logger и передает его следующему звену в цепочке.
type FirstLogger struct {
	NextChain ChainLogger
}

func (f *FirstLogger) Next(s string) {
	fmt.Printf("First logger: %s\n", s)
	if f.NextChain != nil {
		f.NextChain.Next(s)
	}
}

// Второй логгер запишет в консоль, содержит ли входящий текст слово hello, и передаст запрос третьему логгеру. Но, если нет, цепочка будет разорвана
type SecondLogger struct {
	NextChain ChainLogger
}

func (se *SecondLogger) Next(s string) {
	if strings.Contains(strings.ToLower(s), "hello") {
		fmt.Printf("Second logger: %s\n", s)
		if se.NextChain != nil {
			se.NextChain.Next(s)
		}
		return
	}
	fmt.Printf("Finishing in second logging\n\n")
}

// Третий логгер - это логгер общего назначения, называемый Writer Logger, который использует io.Writer интерфейс записи для ведения журнала.
type WriterLogger struct {
	NextChain ChainLogger
	Writer    io.Writer
}

func (w *WriterLogger) Next(s string) {
	if w.Writer != nil {
		w.Writer.Write([]byte("WriterLogger: " + s))
	}
	if w.NextChain != nil {
		w.NextChain.Next(s)
	}
}

type ClosureChain struct {
	NextChain ChainLogger
	Closure   func(string)
}

func (c *ClosureChain) Next(s string) {
	if c.Closure != nil {
		c.Closure(s)
	}
	if c.NextChain != nil {
		c.Next(s)
	}
}
